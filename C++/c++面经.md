# c++面经

## 1、c++的三大特性

### **封装**

​		c 语言中，数据和其函数方法是分开的难以联系，	有了封装以后，使得数据与其行为形成一个有机整体；	使得使用者和设计者分开，private保证了内部实现的私密性，提高了代码的安全性，可维护性和可修改性

**优点：**

​	结合性：使得成员与方法相结合

​	安全性：实现接口机制隐藏内部细节，只留下接口给外界使用

​	高效性：可以实现代码重用



### **继承**

​		类的派生指的是从一个原有的类派生出一个新的类，新类即成为子类，子类会继承父类的成员和方法；



**继承的方式**：

​		1、单一继承：只继承一个父类

​		2、多重继承：继承多个父类，用逗号隔开，如果有相同的成员或方法，调用时需要加类名限定符

​		3、菱形继承：一个子类继承的两个父类，两个父类的父类为同一个类	会产生一个类被继承了多次的情况，需要使用虚继承来避免

**权限问题：**

​	1、public继承，所有的权限不变

​	2、private继承，public和protected变为private，private不可访问

​	3、protected继承，public和protected变为protected，private不可访问



### 多态

​	一个接口，多种效果：	使用同一个接口，但是会根据对象的不同产生不同的效果

**1、静态多态**

​	对于相关的类型，直接实现各自的定义，不需要共有基类，是需要多个类中实现相同要求的接口声明，实质即为模板的具体化

**2、动态多态**

​	内涵：父类指针指向子类对象

​	在基类中定义一个约定的虚函数，多个子类进行继承，在子类中实现具体的功能，通过调用父类的函数传入子类对象，实现多态



c++多态的种类：

​	1>重载，函数重载和运算符重载，编译期

​	2>虚函数，子类的多态性，运行期

​	3>模板，类模板，函数模板，编译期



## 2、面向对象与面向过程

面向过程：分析程序完成所需要的步骤，然后一步步进行实现

面向对象：分析成各个对象，通过实现对象的行为来实现功能



**对比：**	面向过程性能高，不需要创建多个实例对象占用资源

​				面向对象易维护，易扩展，易复用



## 3、结构体和共同体的区别

结构体是一些数据对象的集合，每个对象有各自的空间，sizeof求得的是总和

共同体是各成员共用一段内存，每个对象没有单独空间，sizeof求得的时最长元素的长度



**即：结构体各成员间不会相互影响，而共同体之间的数据会进行相互覆盖**



## 4、struct的内存对齐规则

​	将字节对齐，计算机读取时是按照规律向后读取，内存对齐有利于计算机对于数据的读取，提升效率。如果未对齐，数据可能需要读取两次，白白浪费了时间

**对齐规则：**	

​			在x86下，GCC默认按4字节对齐，但是可以使用`__attribute__`选项改变对齐规则， vs studio上用`#pragma pack (n)`方式改变

​	**空指针：**

```
//sizeof = 8
struct str{
    char p;
    int a;
    int b[0];	
}

//sizeof = 4
struct str{
    int b[0];
}

//sizeof = 1
struct str{
    
}
```



## 5、arr和&arr[0]和&arr的不同

​	三个最终结果都是指向arr的首地址

​	但是当运算时，前两个是以一个int为单位，而&arr是以整个数组为单位的



> arr 本身是左值（但不可仅凭此表达式修改），指代数组对象。不过 arr 会在大多数场合隐式转换成右值表达式 &(arr[0])  ，为指针类型，指向 arr[0] 。&arr 是右值表达式，为指针类型，指向 arr 本身。简单来说就是 arr  本身不是地址而是指代整个数组，只不过会隐式转成指针罢了。



## 6、char a,char a[]

char *a,char *[],char * *a 之间的区别

```
char a 		表示一个基本数据类型char
char a[]	表示一个字符数组
char*a 		表示一个字符串的首地址
char*[]		[]的优先级高于*	所以代表一个指针数组
char**a		与上一行表述相同都为指针数组	即字符串数组
```



## 7、一维数组与二维数组

​		由于其本身都为数组，底层分配的内存都是连续的一片内存，但是二维数组名+1	表示的是直接跳过了一行

**二维数组名无法直接赋值给二级指针:**

​	二维数组名指向的还是相当于一维数组的某个元素，其仍然是指向数组的指针，而二级指针是指向指针的指针，两者有着本质上的区别，所以无法赋值；



## 8、数组指针和指针数组	

**数组指针：**指向数组的指针	`int a[2][3]`	其中a 即为数组指针

**指针数组：**一个 成员为指针的数组		`int *a[2]`

​	

## 9、c++内存分布

```
栈区	stack
共享区
堆区	heap
静态区	 bss	（Block Started by Symbol）
常量区	 data
代码区	 text
```



**栈区：**	从高地址到低地址	保存函数局部变量，函数参数，返回值	保存系统栈帧，局部变量，				函数参数等其他消息

**堆区：**	从低地址到高地址	程序运行过程中 动态分配的内存、

**静态区：** 存储未初始化的全局变量			程序加载时由内核置为零

**常量区：**  存储static变量和所有初始化的全局变量

**代码区：**	代码段在内存中被映射为只读



## **10、static 和const使用**

- **static**

    - 修饰变量：

        - 局部变量：	使局部变量的生命周期变长，由原本的栈区变为了data区，但是作用区域没有改变
        - 全局变量：	将该全局变量变为静态变量，存储位于静态常量区，使其的作用域仅限于该文件，无法通过extern关键字在其他文件声明

    - 修饰函数： 

        ​	使函数作用域仅限于当前文件，防止与其他文件命名冲突

    - static对于类

        1. 成员变量

            用static修饰类的数据成员实际使其成为类的全局变量，会被类的所有对象共享，包括派生类的对象。

            因此，**static成员必须在类外进行初始化，而不能在构造函数内进行初始化。不过也可以用const修饰static数据成员在类内初始化 。**

        2. 成员函数

            用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针。

            静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。

            **不可以同时用const和static修饰成员函数。**

        ​	

- ​	**const**

​	将变量修饰为常量

​	将指针变为常量指针和指向常量的指针

​	作用于函数：

```
const int& fun(int& a); //修饰返回值
int& fun(const int& a); //修饰形参
int& fun(int& a) const{} //const成员函数
```



const不能在类内初始化成员，类为创建实例对象时，编译器无法确定其类型

​	修饰成员函数，确保函数不会修改成员变量的值

​	修饰对象，常量对象，常量对象只能调用常函数



**static和const不能同时修饰一个成员函数**

​	当const修饰时，编译器自动添加一个参数为`const this*`

​	而当用static修饰时，其没有this指针，两者时冲突的



const是将其类型变为常量	而static是不受类的控制，成为类的函数



## 11、static初始化时机，线程安全问题

​	**在c 语言中静态局部变量初始化是在编译阶段进行初始化**

​	**在c++ 中全局或者静态对象只有在使用时才会进行初始化**

​	对于全局变量和const修饰的变量在程序加载完成后完成初始化

​	对于局部静态变量和局部类对象，一般是执行到以后才会进行初始化



线程安全问题：

​	c语言中非局部静态变量的初始化是发生在main函数之前的静态初始化过程中分配内存并初始化，所以是安全的；

​	c++当多个线程执行程序时，当一个线程运行到a的初始化时，其他线程会挂起而不是跳过，所以他的初始化也是安全的；





## 12、C++中局部静态变量的问题

​	局部静态变量的生命周期为整个程序结束，但是作用周期只存在于函数周期内，函数执行结束后，资源不会被释放，但是该变量无法被访问

​	局部静态变量只有执行到该处时才会进行初始化，所以不同位置的局部静态变量初始化顺序不同，靠前的先被初始化，析构的顺序于其相反

**所以会出现两种问题：**

​	1、编译器流水线式的执行程序，如果判断错要执行的代码，会造成时间的大量浪费

​	2、局部变量分散在程序各处，容易使得开发者忽略其之间的联系



## 13、const与指针

`int * const p`

**常量指针：**	指针指向的地址不会发生改变，但是地址的值可以发生改变

`const int *p`

**指针常量：**	指针指向的变量是常量，不能通过解引用的方式修改元素的值



## 14、**指针和引用的区别**



引用的本质为一个常量指针	引用必须进行初始化，且初始化之后无法再引用其他的元素



**引用与常量指针的关系：**

1. ​	大小都为4/ 8 个字节的存储空间，都需要初始化
2. ​    指针允许寻址，而引用不允许寻址
3. ​    引用不能为空， 指针可以为空
4. ​    可以存在指针数组， 但是不能存在引用数组
5. ​    作为函数参数时， 指针传递实际为值传递， 引用传入的是实际元素的地址
6. ​    sizeof指针得到的为4/8   sizeof引用得到的为对象的实际大小



## 15、用const和#define定义常量哪个更好？

​	const更好，const可以包含数据的类型，编译器会对其进行数据检查，更为安全，元素可以被调用传递,const会占用内存，宏定义和const常量可以在函数参数中出现

​	#define定义的常量只会在编译期使用，本质就是将全部出现过的该元素全部替换

> 1. define只是用来进行单纯的文本替换，define常量的声明周期止于编译期，不分配内存空间，它存在于程序的代码段，在实际程序中它只是一个常数，一个命令中的参数并没有实际的存在；而const常量存在于长须的数据段，并在堆栈中分配了空间，const常量在程序中确实存在，且可以被调用、传递
>
> 2. const常量有数据类型，而define常量没有数据类型，编译器可以对const常量进行类型安全检查，但是define不行
>
> 3.很多IDE支持调试const定义的常量，而不支持define定义的常量





## 16、typedef与#define的区别

**typedef：**	本身定义的不是一个新的类型，相当于是给原类型起了一个别名。

​	主要作用：1、	当定义的类型名字很长时，可以起到简化的作用

​						2、	当跨平台时，只需要修改替换的内容，不需要对代码进行改动

**#define：**	宏定义语句，本质就是原文替换，发生在预处理阶段



**区别**：	

1、typedef发生在编译阶段，会进行类型检查	而define发生在预处理阶段，只会进行替换，不会检查

2、define没有作用域，只要是在其定义之后都可以使用，	typedef有自己的作用域

3、对指针的操作不同	如果两个都是定义的int *	typedef相当于定义的类型直接为int *类型

​	而define仅仅只是一个替换，具体意义需要根据位置来判断

```
#define Point	int *
typedef int*  pint;
int i1 = 1;
int i2 = 2;
const Point i1;		//指定的内容不可改变	指向一个常量
const pint	i2;		//指针不可更改，内容可以更改	常量指针

```



## 17、#define<>和#define“ ”的区别

`#define<>`	优先在标准库中寻找，在编译器的设置区域查找

`#define""`	优先在源目录中寻找，如果找不到就会在标准库中寻找

> 如果是引入自己的源代码，只能用“ ” 来查找，否则会报错





## 18、左值和右值

**左值：**	一般可以被取地址的变量为左值，位于赋值运算符的左边，生命周期比较长

**常见的左值：**

​	自定义变量，类的成员，函数名，前置++/-- 成员

​	返回左值引用的函数调用



有以下特征：

1. 可通过取地址运算符获取其地址
2. 可修改的左值可用来赋值
3. 可以用来初始化左值引用



**右值：**	一般位于赋值运算符右边，生命周期一般是在当前行，销毁一般是由编译器来决定的

**常见的右值：**

​	运算表达式，1/2等常量值，字符串值，逻辑表达式，比较表达式，取地址表达式，lambda表达式



**将亡值：**	将亡值是与右值引用相关的表达式，比如，将要被移动的对象、T&&函数返回值、std::move返回值和转换为T&&的类型的转换函数的返回值等。



## 19、左值引用和右值引用

**左值引用：**	相当于给变量起一个别名，两个变量实际上使用的是同一个地址

​	分为左值引用和左值常量引用（无法被修改）

```
//左值引用
int a = 10;
int b = &a;
//左值常量引用
const int tmp = 10;
const int tmp2 = &tmp;
```



**右值引用：**	可以将一个右值绑定到变量上，使其的生命周期由当前行变为与变量的生命周期一致，避免了发生浅拷贝的问题，提高了代码的效率



使用move可以将一个左值强制转换为一个右值，然后通过右值引用实现资源控制权的转移，避免了过于的资源浪费。		但是对于一些基本类型，如int、char[10]等，仍然会发生拷贝，所以move语句对于，含 堆、句柄 等资源的对象更有意义



**特点：**	1、生命周期和变量的周期相同

​				2、右值引用独立于右值和左值，它可以引用一个左值也可以引用一个右值

​				3、T&&在发生自动类型推断的时候，它是未定的引用类型，如果被左值初始化，那就是一个左值，如果被右值引用，那他就是一个右值

​	



完美转发：利用右值引用的多匹配原理，利用std::forward可以保证参数按照原本的类型，去匹配对应的函数重载，实现完美转发！



## 20、深拷贝和浅拷贝

**浅拷贝：**	正常的赋值，但是如果拷贝的对象中有指针时，只会拷贝地址，不会重新分配内存，所以在调用析构函数后，会释放两次，当第一次释放后，该指针成为了悬挂指针，第二次释放时会报错，因此引出了深拷贝

**深拷贝：**	在拷贝指针时，会再次开辟一个新的内存，不会出现一块地址多次释放的问题



但是深拷贝相当于开辟了一个相同大小的内存区域，可能会对资源造成浪费，因此可以使用move语句进行权限移动



## 21、O0、O1、O2、O3优化

**-O0：**		不做任何优化

**-O1:**			对代码分支，常量以及表达式进行优化，减小代码尺寸，缩短执行周期

**-O2：**		 尝试更多的指令集优化和寄存器级优化，会在编译期间占用更多的内存和编译时间

​				（一般都会使用此等级优化）

**-O3：**		 在O2的基础上进行更多的优化， 例如使用伪寄存器网络， 普通函数的内联， 针对循环的更多优化





## 22、c++中四种变量存储类型总结

1、auto 自动存储类型

​	在一个函数内部定义的变量，如果不指定存储的变量的话，那他就是自动存储变量，那么他就是auto 类型的变量，相当于是局部变量	



2、static 静态存储类型

c 语言 静态类型的初始化发生在编译时期，	c++是当执行到该变量时进行初始化



3、extern 外部存储类型

​	当 当前文件需要使用其他文件中定义的变量时，需要添加 extern 关键字



4、register 寄存器存储类型

​	为了加快某些变量或函数参数的处理速度， 在其定义之前添加register 关键字	使用该关键字会将变量缓存于处理器内的寄存器中， 此情况下，无法使用&符号， 因为& 只能得到内存中的地址，无法得到寄存器的地址



## 23、C++中的this指针

**This指针的来源：**	最开始类的底层实现是使用的结构体，但是结构体无法定义成员函数， 所以函数被声明为全局函数，		如果函数中需要使用或者修改成员变量， 那么就可以使用this 指针指向成员变量

**其作用就是指向非静态函数中所作用的对象**

1、this指针隐含于每一个成员函数之间， 指向调用该非静态成员函数的那个对象

2、当一个对象调用成员函数时，编译程序现将对象的地址赋给 this 指针 ， 然后调用成员函数，每次成员函数存取成员变量时，都隐式的使用this指针

3、this指针是一个右值， 不能对其取地址



**This指针的创建**

​	this在成员函数的开始执行前构造，在成员函数的执行结束后销毁

​	如果class类中，没有成员函数，就不会有构造函数， 那么作用就和struct的作用相同了   		   如果是根据Type xx 定义的 对象， 就会在栈中分配内存， this的地址就是这个栈内存的地址。	如果是new 出的一个对象， 那么就会在堆里面分配内存，	this的地址就是这个堆内促的地址

> new操作符根据eax（累加寄存器）	返回分配的地址，然后设置给指针变量。之后调用构造函数，再将内存块地址传给ecx

​	

**在成员函数中调用delete This**

​	对之前的操作无影响， 但是后续如果有涉及到this指针的使用时，会出现报错



**在析构函数中调用delete this**

​	会造成堆栈溢出、 当delete一个对象时， 会调用他的析构函数， 而析构函数仍为delete 所以会发生无限循环



## 24、inline内联函数与宏定义

> inline 对于编译器来说只算是建议， 当内联函数的代码过多时， 编译器不会使其变为内联函数

c 语言的宏定义，没有参数压栈，参数返回，减少了资源的浪费，效率很高

**内联函数的优点：**

​	1、内联函数的作用机理和宏的使用很相似，都是在预编译阶段直接替换，不需要调用函数，直接执行函数体

​	2、内联函数虽然作用很像宏， 但是会进行类型检查， 相当于宏的升级版

​	3、在类中声明的函数， 在调用该函数时， 会自动隐式的将其转为内联函数

​	4、编译器会为所用inline 函数中的局部变量分配空间

​	5、会将内联函数的输入参数和返回值参数会映射到调用函数的局部空间中



- 内联函数不需要压栈，参数返回等步骤，节约了资源
- 内联函数会进行类型检查
- 内联函数运行时可以调试，宏不可以



- 内联函数可能会导致代码膨胀，当内联函数被多次调用时效果更为明显
- inline 函数无法随着函数库的升级而升级， 每一次的修改都需要重新编译



**虚函数是否可以成为内联函数？**

​	当虚函数实现多态时，无法成为内联函数，因为内联函数的替换是发生在预处理阶段的，无法对其进行判断

​	只有当编译器具有实际对象，而不是对象指针或者对象引用时，才会发生







## 25、struct和typedef struct

```
struct test3{
    int a;
    int b;
}test 4;

typedef test3{
	int a;
	int b;
}test 4;
```

**c 语言中：**  语句1中定义结构体变量必须使用	`struct test3 a`

​					语句2中，test4 相当于一个变量类型要用test3 需要加struct 关键字	`struct test3 a`

**c++中：**	   大部分使用第一种， test4 相当于一个结构体变量

​					 			













# c++新特性



## 1、新的类型定义

### long long

> 一般是防止整数溢出，加ll后缀



### char16_t	char32_t

https://zhuanlan.zhihu.com/p/51202412

> 空间浪费比较大，使用较少，中文多数使用UTF-8





## 2、命名空间(C++20)

### 内联命名空间

> 方便库作者的修改调用A::foo()	时，调用的为inline函数的foo函数，可以通过修改inline的位置，实现版本的更改



```
namespace A{
	namespace B{
		int foo(){return 5};
	}
	inline namespace C{
		int foo(){return 5};
	}
}
```



### 简化命名空间

```
namespace A{
	namespace B{
		namespace C{
			int foo(){return 5;}
		}
	}
}

namespace A::B::C{
	int foo(){return 5;}
}
```





## 3、auto

> https://zhuanlan.zhihu.com/p/476448115

> 占位类型说明符	可以作为函数返回值类型，lambda表达式的返回值（增强泛型）



## 4、decltype

> https://zhuanlan.zhihu.com/p/152154499
>
> 无需初始化变量，只需指定类型的元素，编译时得到结果



## 5、函数返回类型后置

> 与decltype相结合，实现函数的泛化

```
template <class T>
auto Add(T a, T b)->decltype(a+b)
{
    return a+b;
}
```



## 6、左值右值

> https://zhuanlan.zhihu.com/p/107445960

> 右值一般为常数，常变量

> &可以左值引用	&&右值饮用	static_cast<.typaneme&&>	返回右值实现完美转发

**移动语义**

std::move实现将临时变量直接拷贝给需要接受的对象

**引用折叠**

右值引用的变量可以被左值引用赋值，凭此可以实现通用引用



## 7、lambda

> https://zhuanlan.zhihu.com/p/384314474

> 感觉作用类似于匿名函数，做算法时配合STL十分方便
>
> 内涵主要是编译器会对其自动优化成一个重载()的一个类

```
sort(arr.begin(), arr.end(), [](int a, int b)->bool{
	return a>b;
})
```

> [] 中的参数：	**=** ：获取所有的值	**&**：获取所有的引用	注：可以捕捉this指针



## 8、非静态成员的默认初始化

> 

```
class A{
public:
    A():a(2){}
    A(int a):a(a) {}
    A(int a, string c):a(a),c(c) {}


    int a{3};
    int b;
    string c{"xx"};
};
```

> 可以通过大括号或者等号进行默认赋值；上述写法感觉可以作为一些有参构造或者set的简便写法
>
> 构造函数的初始化优先级大于定义使的初始化



## 位域

> 当一个数据的类型和其存储的大小存在严重偏差时，可以采用位域来节省空间，即按位存储
>
> 从低往高排

```
struct st{ 
    int one:4;	//低四位
    int two:5;
    int three:6;
};
```

**默认初始化**

```
struct st{ 
    int one:4{2};
    int two:5{3};
    int three:6{4};
};
```



## 9、列表初始化

**直接初始化**

```
int a{8};
```

**拷贝初始化**

```
int a = {10};
```



**列表初始化标准容器**

```
std::vector<int> arr{1, 2, 3};
要求：拥有initializer_list<std::string> a 的有参构造函数

struct A{
	A(initializer_list<std::string> a){
		for(std string *item = a.begin(); item!=a.end(); item++){}
	}
};
```

列表初始化注意事项：

1、隐式缩窄转换问题

```
int a = 10;
char c = a;	//编译正确	支持缩窄转换
char d{a};	//编译错误	不支持缩窄转换
```

2、优先级问题

```
vector<int > a1(5, 5);	//五个5
vector<int> a2{5, 5};	//两个5
```



**指定初始化**

```
struct Point{
	int x;
	int y;
};

Point p{.x = 2, .y = 3 };
```

注：

1、初始化顺序应当和定义的顺序一致

2、不得与其他初始化方法混用

3、必须是聚合类型



## 10、默认和删除函数

> 作用：程序员可以管理删除或添加一些会被覆盖掉的类函数

```
class A{
public:
	A(int num):num(num){}	//会使编译器放弃默认构造函数
	A() = default;	//显式的产生默认构造函数
	
	A(const A&) = delete;	//删除默认的拷贝构造函数
	A& operator=(const A&) = delete;	//删除默认的拷贝赋值运算符函数
	
	
	
	
	int num;
};
```



**不要同时使用explicit和=delete**

explict:	阻止c++的隐式转换

```
class A{
    A(long long ){}
	explicit type(long) = delete;
	
	int num;
};
void foo(type){}
int main(){
	foo(type(58L));		//无法发生隐式转换
	foo(58L);			//发生隐式转换	程序正常执行
}

```

> 同时使用很混乱！！



## 11、联合类型

> 过去的联合类型中要求成员必须为平凡成员(没有自定义的构造函数)

现在要求如果联合中包括非平凡类型，编译器将删除默认构造和析构函数，需要自己写

```
union	A{
	A(){}
	~A(){}
	int x;
	int y;
	std::string s;
	std::vector<int> arr;
}
```



**使用place new的技巧**

> 手动调用构造和析构函数

```
int main(){
	A a;
	new(&a.s) std::string("hello");
    cout<<a.s<<endl;
    a.s.~basic_string();
    
    new(&a.arr)	std::vector<int>;
    a.arr.push_back(5);
    a.arr.~vector();
}
```

