### 1.基础组件

**1.数据序列化**

> google protobuf·

解决数据的跨平台传输	

- 字节序(大小端)	

- 计算机位数	32位， 64位

- 字节对齐	一般是四字节对齐	结构体的内存询问



序列化-> 编码	

> 将原始数据按照某种格式进行封装->得到特殊字符串->将特殊字符串发送给对方

序列化-> 解码

> 接受序列化的特殊字符串->解析->原始数据



**套接字通信**

- tcp
- 线程池  服务器端使用
- 连接池  客户端使用
  - 多线程使用
- 共享内存操作   ->  shm
  - 进程间的通信方式
  - 效率最高
    - 每个通信方式都需要fd
      - 本地套接字
      - 内存映射区  -> mmap  将内存映射到内存映射区 也是需要fd
- 数据库操作   服务器的读写  跟客户端没关系
  - 使用oracle
    - 使用接口 C++接口  OCI



**2.密钥协商的服务器 && 客户端** 

​	客户端->使用终端实现

​	服务器->使用守护进程实现





### 2.数据的加密和解密

#### 加密三要素

- 明文/密文
  - 明文：原始数据
  - 密文：加密数据
- 秘钥
  - 定长的字符串
  - 对称加密->自己生成 
  - 非对称加密->有对应的现成的算法直接生成
- 算法
  - 加密算法  encode
  - 解密算法  decode



#### 常用的加密方式

- 对称加密

  - 密钥比较短

  - 密钥只有一个， 加密解密使用的秘钥相同

  - 加密的效率高

  - 加密的强度不如非对称加密高

  - 秘钥分发困难-> 因为秘钥需要保持别人未知

    - 秘钥不能直接在网络环境中发送

    

- 非对称加密

  - 密钥比较长
  - 加解密使用的秘钥不同
    - 这两个秘钥对保存在不同的文件	公钥文件小， 私钥文件大
    - 公钥
    - 私钥     使用私钥文件可以得到公钥文件
  - 如果使用公钥加密必须使用私钥解密
  - 如果使用私钥加密必须使用公钥加密
  - 效率低
  - 加密强度高
  - 秘钥可以直接分发->分发的公钥



### 3.常用的加密算法

#### 对称加密

- **DES/3DES**
  - DES	以及被破解，不安全
    - 密钥长度 8byte
    - 对数据分段加密， 每组8字节， 最后合并得到一段密文
    - 得到的密文和明文长度相同
  - 3DES
    - 秘钥长度为24byte   在算法内部被平均分为三份	每份8字节
    - 安全， 效率低  相当于将DES进行了三次
    - 处理逻辑       当秘钥1和2相同时相当于为DES
      - 加密：  秘钥1*加密算法
      - 解密：  秘钥2*解密算法
      - 加密：  秘钥3*解密算法
    - 三组秘钥都不同， 加密的等级是最高的
- **AES**
  - 最安全，效率最高的公开的对称加密算法
  - 秘钥长度： 可选的 16byte  24byte  32byte   接受的参数
    - 秘钥越长， 安全性越高， 效率越低
  - **分组加密， 每组的长度为16 字节**
  - 每组的密文和明文长度相同的 16byte
- Blowfish
- RC2/Rc4/RC5
- IDEA
- SKIPJACK



#### 非对称加密

**加密算法**

- **RSA(数字签名和秘钥交换)** 
  - 项目中使用rsa
  - 两个非常大的数字进行数学运行
- ECC(椭圆曲线加密算法)  只能做数字签名
- Diffie-Hellman(DH, 秘钥交换)
- El Gamal(数字签名)
- DSA(数字签名)  

**秘钥交换过程**

```c
// 通信双方为客户端c 服务器端s
// 为什么要进行秘钥交换：
/*
	1. 非对称加密秘钥分发方便， 但是效率低	改进： 使用对称加密
	2. 使用对称加密->秘钥分发困难->改进： 使用非对称加密进行秘钥分发
		分发的是对称加密的秘钥	本质就是一个字符串
*/

//秘钥交换的过程
/*
	1.在服务器端生成一个非堆成加密的密钥对
	2.服务器将公钥发送给客户端， 客户端有了公钥
	3.客户端生成一个随机字符串作为秘钥
	4.客户端使用公钥对生成的堆成加密秘钥进行加密 得到密文
	5.将加密的密文发送给服务器
	6.服务器端使用私钥解密	得到对称加密的秘钥
	7.双方使用同一秘钥进行对称加密通信
*/
// 秘钥交换的过程
```



### 4.Hash算法(单向散列函数)

> 特点：
>
> - 不管原始数据有多长， 通过哈希算法进行计算后得到的长度是定长
>
>   - 是一个二进制格式的字符串
>
> - 只要是原始数据不一样， 得到的结果就不一样
>
> - 有很强的抗碰撞性
>
>   - 碰撞：原始数据不同， 但是通过哈希算法得到相同的结果
>   - 数据不同， 得到的结果就不相同
>
>   - 用哈希算法可以进行数据校验	判断得到的哈希值是否相同	用于检验文件是否被修改
>   - 应用场景：
>     - 数据校验
>     - 登录验证   用于检验密码是否正确， 存储的不是原始密码而是散列值
>     - 秒传
>
> - 不可逆的
>
>   - 得到的结果不能推断出原始数据 
>
> 哈希运算的结果：
>
> - 散列值
> - 指纹
> - 摘要

- MD4/MD5
  - 散列值长度： 16字节
  - 抗碰撞性已经被破解
- SHA-1
  - 散列值长度： 20字节
  - 碰撞性被破解
- SHA-2
  - sha224
    - 散列值长度： 224bit/8	28字节
  - sha256
    - 32 字节
  - sha384
    - 48 字节
  - sha512
    - 64 字节
- SHA3-224/SHA3-256/SHA3-384/SHA3-512



### 5.消息认证码 -> HMAC

> 作用：
>
> - 在通信时， 校验通信的数据有没有被篡改
>
> 使用：
>
> - 消息认证码的本质是一个散列值
> - （原始数据+秘钥） * 哈希函数 = 消息认证码
>   - 最关键的数据： 秘钥
>
> 校验的过程：
>
> - 数据发送方A， 数据接收方B
> - 在A端或B端生成一个秘钥： X， 进行分发-> A B 端都有了秘钥X
> - 在A端进行一个散列值的计算： 得到消息认证码
> - 在A端 将原始数据和散列值同时发送给B
> - 在B端 
>   - 接受原始数据和散列值
>   - 进行运算得到消息认证码
>   - 将消息认证码和散列值对比， 判断是否相同



### 6.数字签名

> 作用：
>
> - 检验数据有没有别篡改
> - 鉴别数据的所有者
> - 不加密原始数据， 只是判断数据的原有者
>
> 数字签名的过程： 私钥加密数据   
>
> - 生成一个秘钥对， 分发公钥
> - 使用哈希函数对原始数据进行运算得到 散列值
> - 使用私钥对散列值加密->密文
> - 将原始数据和密文一块发送给接受者
>
> 校验签名的过程：
>
> - 接受签名一方分发的公钥
> - 接受签名者发送的数据： 原始数据和签名
> - 对数据进行判定
>   - 对接受的原始数据进行哈希运算， 得到散列值new
>     - 保证使用相同的哈希函数
>   - 使用公钥对签名解密    得到散列值old
>   - 比对两个散列值是否相同， 如果相同则说明签名者正确  



### 配置Openssl

> Openssl是一个安全套接字层密码库， 囊括主要的密码算法， 常用的密钥和证书封装管理功能及SSL协议， 并提供丰富的应用程序弓测试或其他目的
>
> SSL是一个安全套接层协议	保证两个应用见通信的保密性和可靠性， 已经成为了保密通讯的工业标准
>
> TLS和SSL本质类似



wsl linux配置

```
1. tar zxvf 压缩包
2. cd 目录
3. ./config
4. sudo make
5. sudo make install

依赖:	
解决无法打开
libssl.so.1.1: cannot open shared object file

sudo apt install build-essential checkinstall zlib1g-dev -y
sudo apt-get install libssl-dev
sudo ln -s /usr/lib/libssl.so.1.1 /usr/lib/libssl.so.1.1
sudo ldconfig
```

