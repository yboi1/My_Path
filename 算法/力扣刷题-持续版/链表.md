### 链表

#### [2807. 在链表中插入最大公约数](https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list/)

> 给你一个链表的头 `head` ，每个结点包含一个整数值。
>
> 在相邻结点之间，请你插入一个新的结点，结点值为这两个相邻结点值的 **最大公约数** 。
>
> 请你返回插入之后的链表。
>
> 两个数的 **最大公约数** 是可以被两个数字整除的最大正整数。

思路: 辗转相除法得到最大公约数, 然后自定义一个插入链表函数实现代码

```c++
class Solution {
public:
    int measure(int x, int y) {
        int z = y;
        while(x%y != 0) {
            z = x%y;
            x = y;
            y = z;
        }
        return z;
    }
    void insert(ListNode* pos, int value) {
        ListNode* tmp = new ListNode(value);
        tmp->next = pos->next;
        pos->next = tmp;
    }
    ListNode* insertGreatestCommonDivisors(ListNode* head) {
        ListNode* list = head;
        while(list->next!=NULL) {
            int num = measure(list->val, list->next->val);
            insert(list, num);
            list = list->next->next;
        }
        return head;
    }
};
```





#### [2181. 合并零之间的节点](https://leetcode.cn/problems/merge-nodes-in-between-zeros/)

> 给你一个链表的头节点 `head` ，该链表包含由 `0` 分隔开的一连串整数。链表的 **开端** 和 **末尾** 的节点都满足 `Node.val == 0` 。
>
> 对于每两个相邻的 `0` ，请你将它们之间的所有节点合并成一个节点，其值是所有已合并节点的值之和。然后将所有 `0` 移除，修改后的链表不应该含有任何 `0` 。
>
>  返回修改后链表的头节点 `head` 

思路: 没当有一个零的时候, 便说明会出现一个新的节点, 所以每次有0时进行操作, 如果开辟一个新的链表的话, 会导致时间和空间复杂度提高, 所以我们可以直接在原链表上进行操作

```c++
class Solution {
public:
    ListNode* mergeNodes(ListNode* head) {
        ListNode* prev = head;
        ListNode* cur = head->next;
        int sum = 0;
        while(cur) {
            if(cur->val) {
                sum += cur->val;
            }
            else {
                prev -> next = cur;
                prev = prev->next;
                cur->val = sum;
                sum = 0;
            }
            cur = cur->next;
        }
        return head->next;
    }
};
```



#### [面试题 04.03. 特定深度节点链表](https://leetcode.cn/problems/list-of-depth-lcci/)

> 给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 `D`，则会创建出 `D` 个链表）。返回一个包含所有深度的链表的数组。

思路: 利用二叉树的层序遍历 将每一层的节点都放到一个新的链表中 再将每一层的链表放入到统一的容器中





```c++
class Solution {
public:
    vector<ListNode*> listOfDepth(TreeNode* tree) {
        queue<TreeNode*> que;
        que.push(tree);
        int size = que.size();
        vector<ListNode*> vec;
        while(!que.empty()){
            ListNode* tmp = new ListNode;
            ListNode* record = tmp;
            for(int i = 0; i < size; i++){
                TreeNode* cur_node = que.front();
                que.pop();
                ListNode* lst = new ListNode(cur_node->val);
                tmp->next = lst;
                tmp = tmp->next;
                if(cur_node->left) que.push(cur_node->left);
                if(cur_node->right) que.push(cur_node->right);
            }
            size = que.size();
            vec.push_back(record->next);
        }
        return vec;
    }
};
```



#### 二叉树层序遍历:

```
// 二叉树层序遍历
queue<TreeNode*> que; que.push(tree); int size = que.size();
while(!que.empty()){
	for(int i = 0; i < size; i++){
    TreeNode* cur_node = que.front(); que.pop();
    // 对每层的每一个节点进行操作
    if(cur_node->left) que.push(cur_node->left);
    if(cur_node->right) que.push(cur_node->right);
  }
  size = que.size();
  //整层操作完之后, 进行下一层的操作
}
```



#### [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

> 给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
>
> ```
> struct Node {
>   int val;
>   Node *left;
>   Node *right;
>   Node *next;
> }
> ```
>
> 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。
>
> 初始状态下，所有 next 指针都被设置为 `NULL`。

思路: 一个简单的层序遍历, 但是由于push报错, 所以只能朴实无华的cv过来了

```c++
class Solution {
public:
    Node *connect(Node *root) {
        if (root == nullptr) {
            return nullptr;
        }
        vector<Node*> q = {root};
        while (!q.empty()) {
            vector<Node*> nxt;
            for (int i = 0; i < q.size(); i++) {
                Node *node = q[i];
                if (i) { // 连接同一层的两个相邻节点
                    q[i - 1]->next = node;
                }
                if (node->left) {
                    nxt.push_back(node->left);
                }
                if (node->right) {
                    nxt.push_back(node->right);
                }
            }
            q = move(nxt);
        }
        return root;
    }
};
```





#### [2130. 链表最大孪生和](https://leetcode.cn/problems/maximum-twin-sum-of-a-linked-list/)

> 在一个大小为 `n` 且 `n` 为 **偶数** 的链表中，对于 `0 <= i <= (n / 2) - 1` 的 `i` ，第 `i` 个节点（下标从 **0** 开始）的孪生节点为第 `(n-1-i)` 个节点 。
>
> - 比方说，`n = 4` 那么节点 `0` 是节点 `3` 的孪生节点，节点 `1` 是节点 `2` 的孪生节点。这是长度为 `n = 4` 的链表中所有的孪生节点。
>
> **孪生和** 定义为一个节点和它孪生节点两者值之和。
>
> 给你一个长度为偶数的链表的头节点 `head` ，请你返回链表的 **最大孪生和** 。

思路: 1. 遍历一遍, 将所有节点的值都保存下来 然后再遍历一次, 找到最大和

```c++
class Solution {
public:
    int pairSum(ListNode* head) {
        int count = 0;
        vector<int> ve(100000);
        while(head){
            ve[count++] = head->val;
            head = head->next;
        }
        int maxc = 0;
        for(int i = 0; i < count/2; i++){
            maxc = max(maxc, ve[i]+ve[count-i-1]);
        }
        return maxc;
    }
};
```



  	 2. 将后半部分链表进行翻转, 然后同时遍历两段链表, 进行求和找最大值

```c++
class Solution {
public: 
    ListNode* reverseList(ListNode* list) {
        ListNode* one = list;
        ListNode* two = list->next;
        one->next = NULL;
        ListNode* tmp;
        while(two){
            tmp = two->next;
            two->next = one;
            one = two;
            two = tmp;
        }
        return one;
    }

public:
    int pairSum(ListNode* head) {
        ListNode *slow = head, *fast = head -> next;
        while(fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        fast = reverseList(slow->next);
        slow = head;
        int maxc = 0;
        while(fast){
            maxc = max(maxc, fast->val+slow->val);
            fast = fast->next;
            slow = slow->next;
        }
        return maxc;
    }
};
```



#### [2487. 从链表中移除节点](https://leetcode.cn/problems/remove-nodes-from-linked-list/)

> 给你一个链表的头节点 `head` 。
>
> 移除每个右侧有一个更大数值的节点。
>
> 返回修改后链表的头节点 `head` 

思路 1. 使用一个栈, 进行遍历链表, 遇到大的就把 栈中比他小的弹出, 最后将栈全部弹出就能得到

```c++
class Solution {
public:
    ListNode* removeNodes(ListNode* head) {
        stack<int> st;
        ListNode* tmp = head;
        st.push(tmp->val);
        tmp = tmp->next;
        while(tmp) {
            while(!st.empty() && tmp->val > st.top()){
                st.pop();
            }
            st.push(tmp->val);
            tmp = tmp->next;
        }

        ListNode* tnode = nullptr;
        while(!st.empty()){
            int val = st.top();
            ListNode* node = new ListNode(val);
            node -> next = tnode;
            tnode = node;
            st.pop();
        }
        return tnode;
    }
};
```

**2. 采用递归思路, 相当于反向遍历链表, 然后根据大小对比, 是返回node还是head**

```c++
class Solution {
public:
    ListNode* removeNodes(ListNode* head) {
        if(head->next == nullptr) return head;
        ListNode* node = removeNodes(head->next);
        if(head->val < node->val) {
            return node;
        } else {
            head->next = node;
            return head;
        }
        return nullptr;
    }
};
```

3. 翻转链表做法, 先反转进行链表操作, 操作完以后再反转回来





#### [LCR 142. 训练计划 IV(合并链表)](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

```c++
class Solution {
public:
    ListNode* trainningPlan(ListNode* l1, ListNode* l2) {
        ListNode* vhead = new ListNode;
        ListNode* ans = vhead;
        while(l1&&l2){
            if(l1->val <= l2->val){
                vhead->next = l1;
                l1 = l1->next;
            } else {
                vhead->next = l2;
                l2 = l2->next;
            }
            vhead = vhead->next;
        }
        if(l1) vhead -> next = l1;
        if(l2) vhead -> next = l2;
        return ans->next;
    }
};
```



#### [LCR 154. 复杂链表的复制](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

> 请实现 `copyRandomList` 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 `next` 指针指向下一个节点，还有一个 `random` 指针指向链表中的任意节点或者 `null`。

思路: 创建一个map 第一遍遍历进行简单的复制, 只拷贝next节点, 同时使用map相当于将两个链表进行映射, 之后第二次遍历进行深拷贝

```c++
class Solution {
public:
    Node* copyRandomList(Node* head) {
       Node* cpList = new Node(0);
       Node* ans = cpList;
       Node* cur = head;
       map<Node*, Node*> arr;
       while(cur){
        Node* newNode = new Node(cur->val);
        cpList->next = newNode;
        arr[cur] = newNode;
        cur = cur->next;
        cpList = cpList->next;
       }
       cpList = ans->next;
       cur = head;
       while(cur) {
        if(cur->random==NULL){
            cpList->random = NULL;
        } else {
            cpList->random = arr[cur->random];
        }
        cur = cur->next;
        cpList = cpList->next;
            
       }
       return ans->next;

    }
};
```



#### [876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)

> 给你单链表的头结点 `head` ，请你找出并返回链表的中间结点。
>
> 如果有两个中间结点，则返回第二个中间结点

> 经典快慢指针问题, 应该记住
>
> 当fast为head时, 是取中间的后一个, 当fast为head->next时是取中间的前一个

```c++
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        if(head->next==NULL) return head;
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast && fast->next){
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;

    }
};
```



### 并查集

#### 并查集基本函数

```
    int find(vector<int> &f, int x){
        if(f[x]==x){
            return x;
        }
        int fa = find(f, f[x]);
        f[x] = fa;
        return fa;
    }

    void merge(vector<int> &f, int x, int y) {
        int fx = find(f, x);
        int fy = find(f, y);
        f[fx] = fy;
    }
```



#### [959. 由斜杠划分区域](https://leetcode.cn/problems/regions-cut-by-slashes/)

> 在由 `1 x 1` 方格组成的 `n x n` 网格 `grid` 中，每个 `1 x 1` 方块由 `'/'`、`'\'` 或空格构成。这些字符会将方块划分为一些共边的区域。
>
> 给定网格 `grid` 表示为一个字符串数组，返回 *区域的数量* 。
>
> 请注意，反斜杠字符是转义的，因此 `'\'` 用 `'\\'` 表示。

思路: 并查集思路, 将每个网格分为四个, 通过并查集来划分他的区域, 然后再遍历时, 上下的2,0无条件合并, 左右的 1,3 无条件合并, 之后如果为/则合并0,3 和1,2 ; 若为\则合并0,1 和2,3 之后使用一个set进行去重, 得到祖先的个数即为划分的区域个数

```c++
class Solution {
public:

    int regionsBySlashes(vector<string>& grid) {
        int n = grid.size();
        vector<int> f(4*n*n);
        for(int i = 0; i < n*n*4; i++){
            f[i] = i;
        }

        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                int idx = i*n+j;
                if(i<n-1){
                    int bottom = idx+n;
                    merge(f, idx*4+2, bottom*4);    // 向下合并
                }
                if(j < n-1){
                    int right = idx+1;
                    merge(f, idx*4+1, right*4+3);
                }
                if(grid[i][j]=='/'){
                    merge(f, idx*4, idx*4+3);
                    merge(f, idx*4+1, idx*4+2);
                } else if(grid[i][j]=='\\'){
                    merge(f, idx*4, idx*4+1);
                    merge(f, idx*4+2, idx*4+3);
                } else {
                    merge(f, idx*4, idx*4+1);
                    merge(f, idx*4+1, idx*4+2);
                    merge(f, idx*4+2, idx*4+3);
                }
            }
        }
        unordered_set<int> fathers;
        for(int i = 0; i < n*n*4; i++){
            int fa = find(f, i);
            fathers.insert(fa);
        }
        return fathers.size();
    }
};
```



#### [LCR 118. 冗余连接](https://leetcode.cn/problems/7LpjUW/)

> 树可以看成是一个连通且 **无环** 的 **无向** 图。
>
> 给定往一棵 `n` 个节点 (节点值 `1～n`) 的树中添加一条边后的图。添加的边的两个顶点包含在 `1` 到 `n` 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 `n` 的二维数组 `edges` ，`edges[i] = [ai, bi]` 表示图中在 `ai` 和 `bi` 之间存在一条边。
>
> 请找出一条可以删去的边，删除后可使得剩余部分是一个有着 `n` 个节点的树。如果有多个答案，则返回数组 `edges` 中最后出现的边。

思路: 本质就是判断删除边以后 公共祖先是否为同一个 若为同一个即可证明可以删除

```c++
vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        int size = edges.size();
        vector<int> f(size);
        for(int i = size-1; i >=0; i--){
            for(int k = 0; k < size; k++){
                    f[k] = k;
            }
            for(int j = 0 ; j < size; j++){
                
                if(i==j){
                    continue;
                } else {
                    merge(f, edges[j][0]-1, edges[j][1]-1);
                }
            }
            int tmp = find(f, f[0]);
            if(i==0){
                int tmp = find(f, f[1]);
            }
             
            bool flag = 1;
            for(int t = 1; t<size; t++){
                if(find(f, f[t])!=tmp){
                    flag = 0;
                    break;
                }
            }
            if(flag){
                return edges[i];
            }

        }
        return edges[0];
    }
```



#### [LCR 116. 省份数量](https://leetcode.cn/problems/bLyHh0/)

> 有 `n` 个城市，其中一些彼此相连，另一些没有相连。如果城市 `a` 与城市 `b` 直接相连，且城市 `b` 与城市 `c` 直接相连，那么城市 `a` 与城市 `c`间接相连。
>
> **省份** 是一组直接或间接相连的城市，组内不含其他没有相连的城市。
>
> 给你一个 `n x n` 的矩阵 `isConnected` ，其中 `isConnected[i][j] = 1`表示第 `i` 个城市和第 `j` 个城市直接相连，而 `isConnected[i][j] = 0`表示二者不直接相连。
>
> 返回矩阵中 **省份** 的数量。

思路 : 经典并查集策略

```c++
class Solution {
public:
    int find(vector<int> &f, int x){
        if(f[x]==x){
            return x;
        }
        int fa = find(f, f[x]);
        f[x] = fa;
        return fa;
    }

    void merge(vector<int> &f, int x, int y) {
        int fx = find(f, x);
        int fy = find(f, y);
        f[fx] = fy;
    }
    int findCircleNum(vector<vector<int>>& isConnected) {
        vector<int> f(isConnected.size(), 0);
        for(int i = 0; i < isConnected.size(); i++){
            f[i] = i;
        }
        for(int i = 0; i < isConnected.size(); i++){
            for(int j = 0; j < isConnected[0].size(); j++){
                if(isConnected[i][j]) merge(f, i, j);
            }
        }
        unordered_set<int> st;
        for(int i = 0; i < isConnected.size(); i++){
            st.insert(find(f, i));
        }
        return st.size();
    }
};
```



#### [1061. 按字典序排列最小的等效字符串](https://leetcode.cn/problems/lexicographically-smallest-equivalent-string/)

> 给出长度相同的两个字符串`s1` 和 `s2` ，还有一个字符串 `baseStr` 。
>
> 其中  `s1[i]` 和 `s2[i]` 是一组等价字符。
>
> - 举个例子，如果 `s1 = "abc"` 且 `s2 = "cde"`，那么就有 `'a' == 'c', 'b' == 'd', 'c' == 'e'`。
>
> 等价字符遵循任何等价关系的一般规则：
>
> -  **自反性** ：`'a' == 'a'`
> -  **对称性** ：`'a' == 'b'` 则必定有 `'b' == 'a'`
> -  **传递性** ：`'a' == 'b'` 且 `'b' == 'c'` 就表明 `'a' == 'c'`
>
> 例如， `s1 = "abc"` 和 `s2 = "cde"` 的等价信息和之前的例子一样，那么 `baseStr = "eed"` , `"acd"` 或 `"aab"`，这三个字符串都是等价的，而 `"aab"` 是 `baseStr` 的按字典序最小的等价字符串
>
> 利用 `s1` 和 `s2` 的等价信息，找出并返回 `baseStr` 的按字典序排列最小的等价字符串。



```c++
class Solution {
public:
    string str = "abcdefghijklmnopqrstuvwxyz";
    int find(vector<int> &f, int x){
        if(f[x]==x){
            return x;
        }
        int fa = find(f, f[x]);
        f[x] = fa;
        return fa;
    }

    void merge(vector<int> &f, int x, int y) {
        int fx = find(f, x);
        int fy = find(f, y);
        if(fx<fy){
            f[fy]=fx;
        } else {
            f[fx]=fy;
        }
    }
    string smallestEquivalentString(string s1, string s2, string baseStr) {
        vector<int > f(27, 0);
        for(int i = 0; i < 27; i++){
            f[i] = i;
        }
        for(int i = 0; i < s1.size(); i++){
            merge(f, str.find(s1[i]), str.find(s2[i]));
        }

        for(int i = 0; i < baseStr.size(); i++){
            baseStr[i] = str[find(f, str.find(baseStr[i]))];
        }
        return baseStr;
    }
};
```



### dfs

#### [695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)

> 给你一个大小为 `m x n` 的二进制矩阵 `grid` 。
>
> **岛屿** 是由一些相邻的 `1` (代表土地) 构成的组合，这里的「相邻」要求两个 `1` 必须在 **水平或者竖直的四个方向上** 相邻。你可以假设 `grid` 的四个边缘都被 `0`（代表水）包围着。
>
> 岛屿的面积是岛上值为 `1` 的单元格的数目。
>
> 计算并返回 `grid` 中最大的岛屿面积。如果没有岛屿，则返回面积为 `0` 

思路: 找到第一个为1的地方, 然后进行递归, 上下左右判断 

```c++
class Solution {
public:
    int dfs(vector<vector<int> >&grid, int y, int x) {
        if(y<0||x<0||y==grid.size()||x==grid[0].size()||grid[y][x]!=1){
            return 0;
        }
        grid[y][x] = 0;
        int dy[4] = {1, -1, 0, 0};
        int dx[4] = {0, 0, -1, 1};
        int ans = 1;
        for(int i = 0; i != 4; i++){
            ans += dfs(grid, y+dy[i], x+dx[i]);
        }
        return ans;
    }

    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int ans = 0;
        for(int y = 0; y < grid.size(); y++){
            for(int x = 0; x < grid[0].size(); x++){
                ans = max(ans, dfs(grid, y, x));
            }
        }
        return ans;
    }
};
```



#### [面试题 16.19. 水域大小](https://leetcode.cn/problems/pond-sizes-lcci/)

> 你有一个用于表示一片土地的整数矩阵`land`，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。

思路: dfs得到区域的数量

```c++
class Solution {
public:
    int dfs(vector<vector<int>>& land, int y, int x){
        if(y<0||x<0||y==land.size()||x==land[0].size()||land[y][x]!=0){
            return 0;
        }
        land[y][x] = 1;
        int count = 1;
        int dy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};
        int dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};
        for(int t = 0; t != 8; t++){
            count += dfs(land, y+dy[t], x+dx[t]);
        }   
        return count;

    }
    vector<int> pondSizes(vector<vector<int>>& land) {
        vector<int> ans;
        for(int i = 0; i < land.size(); i++){
            for(int j = 0; j < land[0].size(); j++){
                if(land[i][j]==0){
                    ans.push_back(dfs(land, i, j));
                }
            }
        }
        sort(ans.begin(), ans.end());
        return ans;
    }
};
```



### 字符串

#### [1769. 移动所有球到每个盒子所需的最小操作数](https://leetcode.cn/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/)

> 有 `n` 个盒子。给你一个长度为 `n` 的二进制字符串 `boxes` ，其中 `boxes[i]` 的值为 `'0'` 表示第 `i` 个盒子是 **空** 的，而 `boxes[i]` 的值为 `'1'` 表示盒子里有 **一个** 小球。
>
> 在一步操作中，你可以将 **一个** 小球从某个盒子移动到一个与之相邻的盒子中。第 `i` 个盒子和第 `j` 个盒子相邻需满足 `abs(i - j) == 1` 。注意，操作执行后，某些盒子中可能会存在不止一个小球。
>
> 返回一个长度为 `n` 的数组 `answer` ，其中 `answer[i]` 是将所有小球移动到第 `i` 个盒子所需的 **最小** 操作数。
>
> 每个 `answer[i]` 都需要根据盒子的 **初始状态** 进行计算。

思路: 1. 两层for循环, 简单粗暴

	2. 维护两个变量, 代表左边需要点次数和右边需要的次数, 然后每次遍历之后维护这两个变量

```c++
class Solution {
public:
    vector<int> minOperations(string boxes) {
        int left = boxes[0]-'0', right = 0, operation = 0;
        int n = boxes.size();
        for(int i = 1; i < n; i++){
            if(boxes[i]=='1'){
                right++;
                operation += i;
            }
        }
        vector<int> ans(n);
        ans[0] = operation;
        for(int i = 1 ;i < n; i++){
            operation = operation + left - right;
            if(boxes[i]=='1'){
                left++;
                right--;
            }
            ans[i] = operation;
        }
        return ans;
    }
};
```





### 贪心

#### [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

> 给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。
>
> 每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:
>
> - `0 <= j <= nums[i]` 
> - `i + j < n`
>
> 返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

思路: 始终保证当前跳跃为最佳解

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        int ans = 0;
        int start = 0;
        int end = 1;
        while(end<nums.size()){
            int maxPos = 0;
            for(int i = start; i < end; i++){
                maxPos = max(maxPos, i+nums[i]);
            }
            start = end;
            end = maxPos + 1;
            ans++;
        }
        return ans;
    }
};
```

