## 9排序

### 插入排序

> 从第二个开始，从后往前，插入到第一个比当前大的数前面

```c++
template <typename T>
void Sort(T arr[], int size){
    if(arr==NULL)   return;
    for(int i = 1; i < size; i++){
        T tmp = arr[i];
        int j;
        for(j = i; j > 0 && arr[j-1]>tmp; j--){
            arr[j] = arr[j-1];
        }
        arr[j] = tmp;
    }
}
```



### 选择排序

每一次遍历都是选择当前最小的数，然后与当前位置++交换

```c++
template<typename T>
void Sort(T *arr, int size){
    for(int i = 0; i < size; i++){
        int min = i, j;
        for(int j = i+1; j < size; j++){
            if(arr[j]<arr[min]) min = j;
        }
        T tmp = arr[i];
        arr[i] = arr[min];
        arr[min] = tmp;
    }
}
```



### 冒泡排序

> 从前往后遍历，将大的数通过不断的交换交换到最后一位，每次遍历的次数减一

```c++
template<typename T>
void Sort(T *arr, int size){
    for(int i = 0; i < size; i++){
        bool flag = true;	// 优化
        for(int j = 0; flag && j < size-i-1; j++){
            if(arr[j]>arr[j+1]){
                flag = false;	// 优化
                T tmp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = tmp;
            }
        }
    }
}
```



### 希尔排序

```c++
template <typename T>
void InsertSort(T arr[], int n, int i){
    int tmp = arr[i], k;
    for(k = i-n; k>=0&&arr[k+n]<arr[k]; k -= n){
        arr[k+n] = arr[k];
    }
    arr[k+n] = tmp;
    
}

template<typename T>
void Sort(T *arr, int size){
    for(int n = size / 2 ; n > 0; n /=2 ){
        for(int i = n; i < size; i++){
            InsertSort(arr, n, i);  //i为起始位置   n为间距大小
        }

    }
}
```



## 二叉树

### 二叉树遍历

#### 前序遍历

`递归法`

```c++
class Solution {
public:
    vector<int> ans;
    void preview(TreeNode *root){
        if(root==NULL)  return;
        ans.push_back(root->val);
        preview(root->left);
        preview(root->right);
    }
    vector<int> postorderTraversal(TreeNode* root) {
        preview(root);
        return ans;
    }
};
```



`迭代法`

> 利用栈的基本原理

```c++
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int>	ans;
        if(root==NULL)	return ans;
        stack<TreeNode*>	st;
        st.push(root);
        TreeNode* tmp;
        while(!st.empty()){
            tmp = st.top();	//无法直接使用pop赋值
            st.pop();
            ans.push_back(tmp->val);
            if(tmp->right) st.push(tmp->right);
            if(tmp->left)	st.push(tmp->left);
        }
        return ans;
    }
};
```



#### 中序遍历

```c++
class Solution {
public:
    vector<int> ans;
    void preview(TreeNode *root){
        if(root==NULL)  return;
        preview(root->left);
        ans.push_back(root->val);
        preview(root->right);
    }
    vector<int> postorderTraversal(TreeNode* root) {
        preview(root);
        return ans;
    }
};
```



`迭代法`

```c++
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int>	ans;
        if(root==NULL)	return ans;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while(cur!=NULL || !st.empty()){	//当前指针不为空||栈中不为空
            if(cur!=NULL){
                st.push(cur);
                cur = cur->left;
            }
            else{
                TreeNode*tmp = st.top();
                st.pop();
                ans.push_back(tmp->val);
                cur = tmp->right;
            }
        }
        return ans;
    }
};
```





#### 后序遍历

```c++
class Solution {
public:
    vector<int> ans;
    void preview(TreeNode *root){
        if(root==NULL)  return;
        preview(root->left);
        preview(root->right);
        ans.push_back(root->val);
    }
    vector<int> postorderTraversal(TreeNode* root) {
        preview(root);
        return ans;
    }
};
```



`迭代法`

> 将前序遍历的左右节点顺序调换，再将得到的结果翻转即可得

```c++
vector<int> postorderTraversal(TreeNode* root) {
        vector<int>	ans;
        if(root==NULL)	return ans;
        stack<TreeNode*>   st;
        st.push(root);
        TreeNode* tmp;
        while(!st.empty()){
            tmp = st.top();	//无法直接使用pop赋值
            st.pop();
            ans.push_back(tmp->val);
            if(tmp->left)	st.push(tmp->left);
            if(tmp->right) st.push(tmp->right);
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
```



#### 层序遍历





#### 堆排序

```c++
void swapar(vector<int> &arr, int i, int j){
    int tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

void bigHeapBuild(vector<int> &arr, int len, int root){
    int largest = root;
    int left = 2*root + 1;
    int right = 2*root + 2;
    if(left<len && arr[left]>arr[largest])   largest = left;
    if(right<len && arr[right]>arr[largest])   largest = right;

    if(largest!=root){   
        swapar(arr, largest, root);
        bigHeapBuild(arr, len, largest);
    }

}

void sortHeap(vector<int> &arr){
    for(int i = (arr.size()/2)-1; i >= 0; i-- ){
        bigHeapBuild(arr, arr.size(), i);
    }
    for(int i = arr.size()-1; i >= 0; i--){
        swapar(arr, 0, i);
        bigHeapBuild(arr, i, 0);
    }

}
```

