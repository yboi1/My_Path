```
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

using namespace std;

const int kNumPhilosophers = 5; // 哲学家数量
const int kNumChopsticks = 5; // 筷子数量

// 定义互斥锁和条件变量
mutex chopstickMutex[kNumChopsticks];
condition_variable chopstickCV[kNumChopsticks];

// 定义哲学家结构体
struct Philosopher {
    int id; // 哲学家编号
    int leftChopstick; // 左筷子编号
    int rightChopstick; // 右筷子编号
};

// 定义哲学家就餐的行为
void eat(Philosopher philosopher) {
    cout << "Philosopher " << philosopher.id << " is eating." << endl;
}

// 定义哲学家思考的行为
void think(Philosopher philosopher) {
    cout << "Philosopher " << philosopher.id << " is thinking." << endl;
}

// 定义哲学家线程的行为
void philosopherThread(Philosopher philosopher) {
    while (true) {
        think(philosopher);
        // 尝试获取左筷子
        unique_lock<mutex> leftChopstickLock(chopstickMutex[philosopher.leftChopstick]);
        chopstickCV[philosopher.leftChopstick].wait(leftChopstickLock);
        // 尝试获取右筷子
        unique_lock<mutex> rightChopstickLock(chopstickMutex[philosopher.rightChopstick]);
        chopstickCV[philosopher.rightChopstick].wait(rightChopstickLock);
        // 同时拿到左右筷子，开始吃饭
        eat(philosopher);
        // 放下右筷子
        rightChopstickLock.unlock();
        chopstickCV[philosopher.rightChopstick].notify_one();
        // 放下左筷子
        leftChopstickLock.unlock();
        chopstickCV[philosopher.leftChopstick].notify_one();
    }
}

int main() {
    // 创建哲学家线程
    Philosopher philosophers[kNumPhilosophers];
    thread philosopherThreads[kNumPhilosophers];
    for (int i = 0; i < kNumPhilosophers; i++) {
        philosophers[i].id = i;
        philosophers[i].leftChopstick = i;
        philosophers[i].rightChopstick = (i + 1) % kNumChopsticks;
        philosopherThreads[i] = thread(philosopherThread, philosophers[i]);
    }
    // 等待所有哲学家线程结束
    for (int i = 0; i < kNumPhilosophers; i++) {
        philosopherThreads[i].join();
    }
    return 0;
}

```

